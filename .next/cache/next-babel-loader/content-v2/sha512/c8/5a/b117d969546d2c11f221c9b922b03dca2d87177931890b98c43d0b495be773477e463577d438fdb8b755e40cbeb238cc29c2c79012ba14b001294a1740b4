{"ast":null,"code":"import { stripe } from '../../services/stripe';\nimport { saveSubscription } from './_lib/manageSubscription';\n\nasync function buffer(readable) {\n  const chunks = [];\n\n  for await (const chunk of readable) {\n    chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk);\n  }\n\n  return Buffer.concat(chunks);\n}\n\nexport const config = {\n  api: {\n    bodyParser: false\n  }\n};\nconst relevantEvents = new Set(['checkout.session.completed', 'customer.subscription.updated', 'customer.subscription.deleted']);\nexport default (async (req, res) => {\n  if (req.method === 'POST') {\n    const buf = await buffer(req);\n    const secret = req.headers['stripe-signature'];\n    let event;\n\n    try {\n      event = stripe.webhooks.constructEvent(buf, secret, process.env.STRIPE_WEBHOOK_SECRET);\n    } catch (err) {\n      return res.status(400).send(`webhook-error: ${err.message}`);\n    }\n\n    const {\n      type\n    } = event;\n\n    if (relevantEvents.has(type)) {\n      try {\n        switch (type) {\n          case 'customer.subscription.updated':\n          case 'customer.subscription.deleted':\n            const subscription = event.data.object;\n            await saveSubscription(subscription.id, subscription.customer.toString(), false);\n            break;\n\n          case 'checkout.session.completed':\n            const checkoutSession = event.data.object;\n            await saveSubscription(checkoutSession.subscription.toString(), checkoutSession.customer.toString(), true);\n            break;\n\n          default:\n            throw new Error('Unhandled event.');\n        }\n      } catch (err) {\n        return res.json({\n          error: 'webhook handler failed.'\n        });\n      }\n    }\n\n    res.json({\n      received: true\n    });\n  } else {\n    res.setHeader('Allow', 'POST');\n    res.status(405).end('Method not allowed');\n  }\n});","map":{"version":3,"sources":["/Users/citelsistema/Desktop/ignite-aulas/Reactjs/Chapter03/ignews/src/pages/api/webhooks.ts"],"names":["stripe","saveSubscription","buffer","readable","chunks","chunk","push","Buffer","from","concat","config","api","bodyParser","relevantEvents","Set","req","res","method","buf","secret","headers","event","webhooks","constructEvent","process","env","STRIPE_WEBHOOK_SECRET","err","status","send","message","type","has","subscription","data","object","id","customer","toString","checkoutSession","Error","json","error","received","setHeader","end"],"mappings":"AAGA,SAASA,MAAT,QAAuB,uBAAvB;AACA,SAASC,gBAAT,QAAiC,2BAAjC;;AAGA,eAAeC,MAAf,CAAsBC,QAAtB,EAA0C;AACxC,QAAMC,MAAM,GAAG,EAAf;;AAEA,aAAY,MAAMC,KAAlB,IAA2BF,QAA3B,EAAqC;AACnCC,IAAAA,MAAM,CAACE,IAAP,CACE,OAAOD,KAAP,KAAiB,QAAjB,GAA4BE,MAAM,CAACC,IAAP,CAAYH,KAAZ,CAA5B,GAAiDA,KADnD;AAGD;;AAED,SAAOE,MAAM,CAACE,MAAP,CAAcL,MAAd,CAAP;AAED;;AAED,OAAO,MAAMM,MAAM,GAAG;AACpBC,EAAAA,GAAG,EAAE;AACHC,IAAAA,UAAU,EAAE;AADT;AADe,CAAf;AAMP,MAAMC,cAAc,GAAG,IAAIC,GAAJ,CAAQ,CAC7B,4BAD6B,EAE7B,+BAF6B,EAG7B,+BAH6B,CAAR,CAAvB;AAMA,gBAAe,OAAOC,GAAP,EAA6BC,GAA7B,KAAsD;AACnE,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,UAAMC,GAAG,GAAG,MAAMhB,MAAM,CAACa,GAAD,CAAxB;AACA,UAAMI,MAAM,GAAGJ,GAAG,CAACK,OAAJ,CAAY,kBAAZ,CAAf;AAEA,QAAIC,KAAJ;;AAEA,QAAI;AACFA,MAAAA,KAAK,GAAGrB,MAAM,CAACsB,QAAP,CAAgBC,cAAhB,CAA+BL,GAA/B,EAAoCC,MAApC,EAA4CK,OAAO,CAACC,GAAR,CAAYC,qBAAxD,CAAR;AACD,KAFD,CAEC,OAAOC,GAAP,EAAY;AACX,aAAOX,GAAG,CAACY,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAsB,kBAAiBF,GAAG,CAACG,OAAQ,EAAnD,CAAP;AACD;;AAED,UAAM;AAACC,MAAAA;AAAD,QAASV,KAAf;;AAEA,QAAIR,cAAc,CAACmB,GAAf,CAAmBD,IAAnB,CAAJ,EAA8B;AAC5B,UAAI;AACF,gBAAQA,IAAR;AACE,eAAK,+BAAL;AACA,eAAK,+BAAL;AAEE,kBAAME,YAAY,GAAGZ,KAAK,CAACa,IAAN,CAAWC,MAAhC;AAEA,kBAAMlC,gBAAgB,CACpBgC,YAAY,CAACG,EADO,EAEpBH,YAAY,CAACI,QAAb,CAAsBC,QAAtB,EAFoB,EAGpB,KAHoB,CAAtB;AAMF;;AAGA,eAAK,4BAAL;AACE,kBAAMC,eAAe,GAAGlB,KAAK,CAACa,IAAN,CAAWC,MAAnC;AAEA,kBAAMlC,gBAAgB,CACpBsC,eAAe,CAACN,YAAhB,CAA6BK,QAA7B,EADoB,EAEpBC,eAAe,CAACF,QAAhB,CAAyBC,QAAzB,EAFoB,EAGpB,IAHoB,CAAtB;AAMF;;AAEA;AACE,kBAAM,IAAIE,KAAJ,CAAU,kBAAV,CAAN;AA3BJ;AA6BD,OA9BD,CA8BC,OAAOb,GAAP,EAAY;AACX,eAAOX,GAAG,CAACyB,IAAJ,CAAS;AAAEC,UAAAA,KAAK,EAAE;AAAT,SAAT,CAAP;AACD;AACF;;AAED1B,IAAAA,GAAG,CAACyB,IAAJ,CAAS;AAAEE,MAAAA,QAAQ,EAAE;AAAZ,KAAT;AAED,GApDD,MAoDO;AACL3B,IAAAA,GAAG,CAAC4B,SAAJ,CAAc,OAAd,EAAuB,MAAvB;AACA5B,IAAAA,GAAG,CAACY,MAAJ,CAAW,GAAX,EAAgBiB,GAAhB,CAAoB,oBAApB;AACD;AACF,CAzDD","sourcesContent":["import { NextApiRequest, NextApiResponse} from 'next'\nimport { Readable } from 'stream'\nimport Stripe from 'stripe';\nimport { stripe } from '../../services/stripe'\nimport { saveSubscription } from './_lib/manageSubscription'\n\n\nasync function buffer(readable: Readable) {\n  const chunks = [];\n\n  for await ( const chunk of readable) {\n    chunks.push(\n      typeof chunk === 'string' ? Buffer.from(chunk) : chunk\n    );\n  }\n\n  return Buffer.concat(chunks);\n\n}\n\nexport const config = {\n  api: {\n    bodyParser: false,\n  }\n}\n\nconst relevantEvents = new Set([\n  'checkout.session.completed',\n  'customer.subscription.updated',\n  'customer.subscription.deleted',\n])\n\nexport default async (req: NextApiRequest , res: NextApiResponse) => {\n  if (req.method === 'POST') {\n    const buf = await buffer(req);\n    const secret = req.headers['stripe-signature']\n\n    let event: Stripe.Event;\n\n    try {\n      event = stripe.webhooks.constructEvent(buf, secret, process.env.STRIPE_WEBHOOK_SECRET);\n    }catch (err) {\n      return res.status(400).send(`webhook-error: ${err.message}`);\n    }\n\n    const {type} = event;\n\n    if (relevantEvents.has(type)) {\n      try {\n        switch (type) {\n          case 'customer.subscription.updated':\n          case 'customer.subscription.deleted':\n\n            const subscription = event.data.object as Stripe.Subscription;\n\n            await saveSubscription(\n              subscription.id,\n              subscription.customer.toString(),\n              false,             \n            );\n\n          break;\n\n\n          case 'checkout.session.completed':\n            const checkoutSession = event.data.object as Stripe.Checkout.Session \n\n            await saveSubscription(\n              checkoutSession.subscription.toString(),\n              checkoutSession.customer.toString(),\n              true\n            )\n\n          break;\n\n          default:\n            throw new Error('Unhandled event.')\n        }\n      }catch (err) {\n        return res.json({ error: 'webhook handler failed.'})\n      }\n    } \n     \n    res.json({ received: true })\n        \n  } else {\n    res.setHeader('Allow', 'POST')\n    res.status(405).end('Method not allowed')\n  }  \n}\n"]},"metadata":{},"sourceType":"module"}